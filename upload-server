#!/usr/bin/env python3
import argparse, base64, crypt, hmac, http.server, os
import random, re, ssl, string, subprocess, sys, threading

AUTOGEN_CERT = "fyl-localhost.pem"
PASSWORD_LEN = 6
MAX_LOGIN_FAILS = 4

class UserError(Exception):
    pass

class ServerHandler:

    def __init__(self, server, req_handler):
        self.server = server
        self.req_handler = req_handler

    def render(self, message='', code=200):
        html = (
            '<form style="font-family: sans-serif" method="post" enctype="multipart/form-data">'
            '<ol>'
            '<li><input type="text" name="password" autocomplete="off" placeholder="Password"/></li>'
            '<li><input type="file" name="file"/></li>'
            '<li><button type="submit">Upload</button></li>'
            '</ol>'
            '<strong style="color: red">{message}</strong>'
            '</form>'
        ).format(message=message)
        self.respond(
            html,
            headers={"Content-Type": "text/html"},
            code=code,
        )

    def get(self):
        self.render()

    def post(self):
        try:
            self.inner_post()
        except UserError as e:
            self.render('Bad Request: {}'.format(e), code=400)
            raise
        except:
            self.render('Server Error', code=500)
            raise

    def inner_post(self):
        content_type = self.req_handler.headers["Content-Type"]
        _, boundary = content_type.split("=", 1)
        boundary = boundary.encode("utf-8")
        start_boundary = b"--" + boundary + b"\r\n"
        mid_boundary = b"\r\n--" + boundary + b"\r\n"
        end_boundary = b"\r\n--" + boundary + b"--\r\n"
        n = int(self.req_handler.headers["Content-Length"])

        reader = Reader(self.req_handler.rfile, b"", 512, n)
        _, found = reader.read_until(start_boundary, 50)
        if not found:
            raise UserError("start boundary not found")

        name = parse_multipart_header(reader)
        if name != b"password":
            raise UserError("expected password")
        password, found = reader.read_until(mid_boundary, 512)
        if not found:
            raise UserError("mid boundary not found")
        if not self.is_authorized(password.decode("utf-8")):
            return

        name = parse_multipart_header(reader)
        if name != b"file":
            raise UserError("expected file")
        partial_matcher = PartialMatcher(end_boundary)
        with open(self.server.output_path, "wb") as f:
            while True:
                chunk, found = reader.read_chunk_until(partial_matcher)
                f.write(chunk)
                if found:
                    break
                if not chunk:
                    raise UserError("end boundary not found")

        self.respond("OK\n")
        sys.stderr.write("Upload complete.\n")
        sys.stderr.flush()
        self.shutdown(None)

    def is_authorized(self, password):
        crypt_password = self.server.crypt_password
        if (crypt_password is None or
            not hmac.compare_digest(crypt_password,
                                    crypt.crypt(password, crypt_password))):
            sys.stderr.write("(!) Failed login ({}/{}) with password {!r}\n".format(
                self.server.login_fails,
                self.server.max_login_fails,
                password,
            ))
            sys.stderr.flush()
            retry = self.mark_auth_fail()
            self.render(message="Invalid password\n", code=401)
            if not retry:
                self.server.crypt_password = None
                self.shutdown("Too many login failures, bye!")
            return

        return True

    def mark_auth_fail(self):
        self.server.login_fails += 1
        return self.server.login_fails < self.server.max_login_fails

    def respond(self, content, code=200, headers={}):
        content = content.encode("utf-8")
        self.req_handler.send_response(code)
        self.req_handler.send_header("Content-Length", len(content))
        headers["Content-Type"] = headers.get("Content-Type", "text/plain")
        for k, v in headers.items():
            self.req_handler.send_header(k, v)
        self.req_handler.end_headers()
        self.req_handler.wfile.write(content)

    def shutdown(self, msg):
        self.server.exit_msg = msg
        threading.Thread(
            target=self.req_handler.server.shutdown,
            daemon=True,
        ).start()

class Server:

    def __init__(self, output_path, crypt_password, max_login_fails):
        self.output_path = output_path
        self.crypt_password = crypt_password
        self.login_fails = 0
        self.max_login_fails = max_login_fails

    def handler(self):
        server = self
        class Handler(http.server.BaseHTTPRequestHandler):
            def do_GET(self):
                return ServerHandler(server, self).get()
            def do_POST(self):
                return ServerHandler(server, self).post()
        return Handler

def parse_host_port(host_port):
    host, port = host_port.split(":")
    return host, int(port)

def gen_password(random, alphabet, length):
    return "".join(random.choice(alphabet) for _ in range(length))

def gen_creds():
    password = gen_password(
        random.SystemRandom(),
        string.ascii_lowercase,
        PASSWORD_LEN,
    )
    return password, crypt.crypt(password)

def get_cert(path):
    if not path:
        path = os.path.join(
            os.environ.get("XDG_CACHE_HOME", os.path.expanduser("~/.cache")),
            AUTOGEN_CERT,
        )
        if not os.path.exists(path):
            subprocess.run([
                "openssl",
                "req",
                "-x509",
                "-newkey", "rsa:4096",
                "-days", "365",
                "-subj", "/CN=localhost",
                "-nodes",
                "-keyout", path,
                "-out", path,
            ])
    return path

class PartialMatcher:

    def __init__(self, delimiter):
        # Either partial matches at the end or full matches anywhere.
        # Example: r"\Z|a(\Z|b(\Z|c(...)))"
        self.length = len(delimiter)
        self.pattern = re.compile(
            b"".join([rb"\Z|" + re.escape(bytes([c])) + b"(" for c in delimiter])
            + b")" * len(delimiter)
        )

class Reader:

    def __init__(self, f, buf, read_size, max_length):
        self._f = f
        self._buf = buf
        self._read_size = read_size
        self._max_length = max_length

    def read_into_buf(self):
        chunk = self._f.read(min(self._read_size, self._max_length))
        self._buf += chunk
        self._max_length -= len(chunk)
        return bool(chunk)

    def consume_buf(self):
        buf = self._buf
        self._buf = b""
        return buf

    def read_chunk_until(self, partial_matcher):
        while True:
            start, end = partial_matcher.pattern.search(self._buf).span()
            is_full_match = end - start == partial_matcher.length
            prematch = self._buf[:start]
            self._buf = self._buf[end if is_full_match else start:]
            if prematch or is_full_match:
                return prematch, is_full_match
            if not self.read_into_buf():
                return self.consume_buf(), False

    def read_until(self, delimiter, stop_len):
        partial_matcher = PartialMatcher(delimiter)
        chunks = []
        n = 0
        while True:
            chunk, found = self.read_chunk_until(partial_matcher)
            chunks.append(chunk)
            n += len(chunk)
            if n >= stop_len or found or not chunk:
                return b"".join(chunks), found

def parse_multipart_header(reader):
    name = ""
    while True:
        line, found = reader.read_until(b"\r\n", 512)
        if not found:
            raise ValueError("EOL not found")
        if not line.strip():
            return name
        pattern = rb'(?i)Content-Disposition:\s*form-data;\s*name="([^"]*)"'
        match = re.search(pattern, line)
        if match:
            name = match.group(1)

if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument("--cert", "-c",
                   help="Leave blank to create a self-signed certificate.")
    p.add_argument("--listen-host-port", "-l",
                   type=parse_host_port, required=True)
    p.add_argument("--output-path", "-o", required=True)
    args = p.parse_args()
    password, crypt_password = gen_creds()
    sys.stdout.write("".join([
        "Listening: {}:{} (HTTPS)\n".format(*args.listen_host_port),
        "Password: {}\n".format(password),
    ]))
    sys.stdout.flush()
    server = Server(
        output_path=args.output_path,
        crypt_password=crypt_password,
        max_login_fails=MAX_LOGIN_FAILS,
    )
    httpd = http.server.HTTPServer(args.listen_host_port, server.handler())
    httpd.socket = ssl.wrap_socket(
        httpd.socket,
        certfile=get_cert(args.cert),
        server_side=True,
    )
    httpd.serve_forever()
    sys.exit(server.exit_msg)
