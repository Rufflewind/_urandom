<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>CIELAB color picker</title>
    <style>
      main {
          display: table;
          padding: 10px;
          width: 300px;
          height: 0;
      }
      #resize {
          overflow: hidden;
          padding: 10px;
          resize: both;
          width: 300px;
          height: 300px;
          user-select: none;
      }
      #canvas {
          display: table-row;
          height: 100%;
          width: 100%;
          cursor: crosshair;
      }
      #slider {
          display: table-row;
          width: 100%;
          height: 40px;
      }
      input {
          font-family: monospace;
      }
      #preview {
          display: inline-block;
          border: 1px solid black;
          width: 50px;
          height: 50px;
      }
    </style>
  </head>
  <body>
    <h1><a href="https://en.wikipedia.org/wiki/Lab_color_space">CIELAB</a> color picker</h1>
    <main>
      <div id="resize">
        <canvas id="canvas"></canvas>
      </div>
      <input id="slider" type="range" value="50" step="1" min="0" max="100"/>
      <input id="color" type="text"/>
      <input id="max-chroma" type="number" value="0.75" step="0.05" min="0" max="10"/>
      <div id="preview"></div>
    </main>
    <form>
      <p><label><input id="view-hcl" type="radio" name="view" checked="checked"/> (chroma, hue) vs lightness</label></p>
      <p><label><input id="view-hlc" type="radio" name="view"/> (lightness, hue) vs chroma</label></p>
    </form>
    <script>
"use strict";

// TODO: ideally to make current color less lossy we should store the exact
// coordinates + coordinate system rather than use exclusively XYZ

// https://stackoverflow.com/a/5624139
function hexToRgb(hex) {
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function(m, r, g, b) {
        return r + r + g + g + b + b;
    });
    var s = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!s) {
        return null;
    }
    return [parseInt(s[1], 16), parseInt(s[2], 16), parseInt(s[3], 16)];
}

// https://stackoverflow.com/a/19765382
function rgbToHex(r, g, b) {
    return "#" + (0x1000000 + ((r << 16) | (g << 8) | b)).toString(16).slice(1);
}

var WHITE_XYZ = [0.95047, 1.0, 1.08883];
var CIELAB_D = 6.0 / 29.0;
var CIELAB_M = Math.pow(29.0 / 6.0, 2) / 3.0;
var CIELAB_C = 4.0 / 29.0;
var CIELAB_A = 3.0;
var CIELAB_RECIP_A = 1.0 / CIELAB_A;
var CIELAB_POW_D_A = Math.pow(CIELAB_D, CIELAB_A);
var CIELAB_MATRIX = [[ 0.0 ,  1.16,  0.0 ],
                     [ 5.0 , -5.0 ,  0.0 ],
                     [ 0.0 ,  2.0 , -2.0 ]];
var CIELAB_MATRIX_INV = [[ 0.86206897,  0.2       ,  0.0       ],
                         [ 0.86206897,  0.0       ,  0.0       ],
                         [ 0.86206897,  0.0       , -0.5       ]];
var CIELAB_OFFSET = -0.16;

function cielab_from_linear(x) {
    return x <= CIELAB_POW_D_A ?
           CIELAB_M * x + CIELAB_C :
           Math.pow(x, CIELAB_RECIP_A);
}

function cielab_to_linear(y) {
    return y <= CIELAB_D ?
           (y - CIELAB_C) / CIELAB_M :
           Math.pow(y, CIELAB_A);
}

function matrix_vector_multiply(m, v, out) {
    out[0] = m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2];
    out[1] = m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2];
    out[2] = m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2];
}

function cielab_to_xyz(lab, xyz) {
    lab[0] -= CIELAB_OFFSET;
    matrix_vector_multiply(CIELAB_MATRIX_INV, lab, xyz);
    lab[0] += CIELAB_OFFSET;
    xyz[0] = cielab_to_linear(xyz[0]) * WHITE_XYZ[0];
    xyz[1] = cielab_to_linear(xyz[1]) * WHITE_XYZ[1];
    xyz[2] = cielab_to_linear(xyz[2]) * WHITE_XYZ[2];
}

function cielab_from_xyz(xyz, lab) {
    var fxyz = [
        cielab_from_linear(xyz[0] / WHITE_XYZ[0]),
        cielab_from_linear(xyz[1] / WHITE_XYZ[1]),
        cielab_from_linear(xyz[2] / WHITE_XYZ[2])
    ];
    matrix_vector_multiply(CIELAB_MATRIX, fxyz, lab);
    lab[0] += CIELAB_OFFSET;
}

var SRGB_D = 0.04045;
var SRGB_M = 12.92;
var SRGB_A = 2.4;
var SRGB_K = 0.055;
var SRGB_MATRIX = [[ 3.2406, -1.5372, -0.4986],
                   [-0.9689,  1.8758,  0.0415],
                   [ 0.0557, -0.204 ,  1.057 ]];
var SRGB_MATRIX_INV = [[ 0.41239559,  0.35758343,  0.18049265],
                       [ 0.21258623,  0.7151703 ,  0.0722005 ],
                       [ 0.01929722,  0.11918386,  0.95049713]];

function srgb_from_linear(x, bad) {
    if (x > 1.0) {
        x = 1.0;
        bad[0] = true;
    } else if (x < 0.0) {
        x = 0.0;
        bad[0] = true;
    }
    return x <= SRGB_D / SRGB_M ?
           SRGB_M * x :
           (1 + SRGB_K) * Math.pow(x, 1 / SRGB_A) - SRGB_K;
}

function srgb_to_linear(y, bad) {
    if (y > 1.0) {
        y = 1.0;
    } else if (y < 0.0) {
        y = 0.0;
    }
    return y <= SRGB_D ?
           y / SRGB_M :
           Math.pow((y + SRGB_K) / (1 + SRGB_K), SRGB_A);
}

function srgb_from_xyz(xyz, rgb, bad) {
    matrix_vector_multiply(SRGB_MATRIX, xyz, rgb);
    rgb[0] = srgb_from_linear(rgb[0], bad);
    rgb[1] = srgb_from_linear(rgb[1], bad);
    rgb[2] = srgb_from_linear(rgb[2], bad);
}

function srgb_to_xyz(rgb, xyz) {
    matrix_vector_multiply(SRGB_MATRIX_INV, [srgb_to_linear(rgb[0]),
                                             srgb_to_linear(rgb[1]),
                                             srgb_to_linear(rgb[2])], xyz);
}

function cartesian(toXyz, sliderValue) {
    var inp = [0.0, 0.0, 0.0];
    var xyz = [0.0, 0.0, 0.0];
    var rgb = [0.0, 0.0, 0.0, 1.0];
    inp[2] = sliderValue;
    var bad = [false];
    for (var y = 0; y < height; ++y) {
        inp[1] = 1.0 - y / height;
        for (var x = 0; x < width; ++x) {
            inp[0] = x / width;
            toXyz(inp, xyz);
            bad[0] = false;
            rgb[3] = 1.0;
            srgb_from_xyz(xyz, rgb, bad);
            if (bad[0]) {
                var desat = 0.2;
                var dim = 0.1;
                var avg = (rgb[0] + rgb[1] + rgb[2]) / 3.0;
                rgb[0] = (rgb[0]) * (1.0 - desat) + avg * desat - dim;
                rgb[1] = (rgb[1]) * (1.0 - desat) + avg * desat - dim;
                rgb[2] = (rgb[2]) * (1.0 - desat) + avg * desat - dim;
            }
            data[0 + 4 * (x + width * y)] = 255.0 * rgb[0];
            data[1 + 4 * (x + width * y)] = 255.0 * rgb[1];
            data[2 + 4 * (x + width * y)] = 255.0 * rgb[2];
            data[3 + 4 * (x + width * y)] = 255.0 * rgb[3];
        }
    }
}

var viewHcl = {
    mask: function(ctx) {
        ctx.beginPath();
        ctx.arc(width / 2.0, height / 2.0, width / 2.0, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();
    },
    toXyz: function(inp, xyz) {
        var lab = [inp[2],
                   (2.0 * inp[0] - 1.0) * maxChroma,
                   (2.0 * inp[1] - 1.0) * maxChroma];
        cielab_to_xyz(lab, xyz);
    },
    fromXyz: function(xyz, inp) {
        var lab = [0.0, 0.0, 0.0]
        cielab_from_xyz(xyz, lab);
        inp[0] = (lab[1] / maxChroma + 1.0) / 2.0;
        inp[1] = (lab[2] / maxChroma + 1.0) / 2.0;
        inp[2] = lab[0];
    }
};

var viewHlc = {
    mask: function(ctx) {
        ctx.beginPath();
        ctx.arc(width / 2.0, height / 2.0, width / 2.0, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();
    },
    toXyz: function(inp, xyz) {
        var x = 2.0 * inp[0] - 1.0;
        var y = 2.0 * inp[1] - 1.0;
        var r = Math.sqrt(x * x + y * y);
        var lab;
        if (r < 1e-8) {
            lab = [1.0,
                   0.0,
                   0.0];
        } else {
            lab = [1.0 - r,
                   maxChroma * inp[2] * x / r,
                   maxChroma * inp[2] * y / r];
        }
        cielab_to_xyz(lab, xyz);
    },
    fromXyz: function(xyz, inp) {
        var lab = [0.0, 0.0, 0.0]
        cielab_from_xyz(xyz, lab);
        var r = 1.0 - lab[0];
        var c = Math.sqrt(lab[1] * lab[1] + lab[2] * lab[2]);
        if (c < 1e-8) {
            inp[0] = 0.5 + (1.0 - lab[0]) * 0.5;
            inp[1] = 0.5;
        } else {
            inp[0] = (lab[1] / c * r + 1.0) / 2.0;
            inp[1] = (lab[2] / c * r + 1.0) / 2.0;
        }
        inp[2] = c / maxChroma;
    }
};

var view = viewHcl;

var drawScheduled = false;
var drawFull = false;
function redraw(full) {
    drawFull = drawFull || full;
    if (drawScheduled) {
        return;
    }
    drawScheduled = true;
    window.requestAnimationFrame(function() {

        var rgb = [0.0, 0.0, 0.0];
        var bad = [false];
        srgb_from_xyz(currentXyz, rgb, bad);
        var hex = rgbToHex(rgb[0] * 255, rgb[1] * 255, rgb[2] * 255);
        colorText.value = hex;
        document.getElementById("preview").style.backgroundColor = hex;

        var inp = [0.0, 0.0, 0.0];
        view.fromXyz(currentXyz, inp);

        var cursorX = inp[0] * width;
        var cursorY = (1.0 - inp[1]) * height;
        slider.value = slider.max * inp[2];

        if (drawFull) {
            console.time("pixeler");
            cartesian(view.toXyz, inp[2]);
            console.timeEnd("pixeler");
        }

        createImageBitmap(img).then(function(img) {

        ctx.clearRect(0, 0, width, height);
        ctx.save();
        view.mask(ctx);
        ctx.drawImage(img, 0, 0);
        ctx.restore();

        ctx.strokeStyle = "white";
        ctx.beginPath();
        ctx.arc(cursorX, cursorY, 4, 0, Math.PI * 2);
        ctx.stroke();

        ctx.strokeStyle = "black";
        ctx.beginPath();
        ctx.arc(cursorX, cursorY, 5, 0, Math.PI * 2);
        ctx.stroke();

        });

        drawScheduled = false;
        drawFull = false;
    });
}

var currentXyz = WHITE_XYZ.map(function(x) { return x / 2.0; } );
function setCursor(e) {
    if (!(e.buttons & 1)) {
        return;
    }
    var rx = e.offsetX / canvas.clientWidth;
    var ry = e.offsetY / canvas.clientHeight;
    var sliderValue = slider.value / slider.max;
    var inp = [rx, 1.0 - ry, sliderValue];
    view.toXyz(inp, currentXyz);

    redraw(false);
}

var canvas = document.getElementById("canvas");
canvas.addEventListener("mousedown", setCursor);
canvas.addEventListener("mousemove", setCursor);
canvas.addEventListener("mouseup", setCursor);

var hclRadio = document.getElementById("view-hcl");
hclRadio.addEventListener("change", function() {
    view = viewHcl;
    redraw(true);
});
var hlcRadio = document.getElementById("view-hlc");
hlcRadio.addEventListener("change", function() {
    view = viewHlc;
    redraw(true);
});

var slider = document.getElementById("slider");
slider.addEventListener("input", function(e) {
    var inp = [0.0, 0.0, 0.0];
    view.fromXyz(currentXyz, inp);
    inp[2] = slider.value / slider.max;
    view.toXyz(inp, currentXyz);
    redraw(true);
});

var maxChromaInput = document.getElementById("max-chroma");
var maxChroma = maxChromaInput.value;
maxChromaInput.addEventListener("input", function(e) {
    maxChroma = maxChromaInput.value
    redraw(true);
});

var colorText = document.getElementById("color");
colorText.addEventListener("blur", function(e) {
    var rgb = hexToRgb(this.value);
    if (rgb === null) {
        return;
    }
    srgb_to_xyz([rgb[0] / 255.0, rgb[1] / 255.0, rgb[2] / 255.0], currentXyz);
    redraw(true);
});

var ctx = canvas.getContext("2d");
var width = 400;
var height = 400;
var cursorX = width / 2;
var cursorY = height / 2;
canvas.width = width;
canvas.height = height;

var img = ctx.createImageData(width, height);
var data = img.data;
redraw(true);
</script>
  </body>
</html>
