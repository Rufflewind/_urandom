<!doctype html>
<html>
  <head>
    <title>Ember Court Planner</title>
    <style>
      html {
          font-family: sans-serif;
          background: #111;
          color: #ddd;
      }
      img.icon {
          border: 1px solid rgba(0, 0, 0, 0);
          border-radius: 2px;
          vertical-align: middle;
      }
      .matrix {
          vertical-align: middle;
          border-collapse: collapse;
          display: inline-block;
          margin: 5px;
      }
      .matrix td, .matrix th {
          border: solid 1px #777;
          padding: 4px;
          text-align: left;
      }
      .matrix th {
          background: #000;
      }
      .matrix td > label {
          display: block;
      }
      .matrix tr:has(> td > input[type="checkbox"]:checked) td.selectable {
          background: #292929;
      }
      .level-low.atmosphere-low img,
      .level-high.atmosphere-high img {
          border: 1px solid #ddd;
      }
      .level-low.atmosphere-high img,
      .level-high.atmosphere-low img {
          opacity: 20%;
      }
      .atmosphere-mid img {
          opacity: 40%;
      }
    </style>
  </head>
  <body>
    <table id="guests" class="matrix"></table>
    <table id="amenities" class="matrix"></table>
    <script>
      function* chain(...iters) {
          for (const items of iters) {
              for (const item of items) {
                  yield item;
              }
          }
      }

      function* batched(size, items) {
          let batch = [];
          for (const item of items) {
              batch.push(item);
              if (batch.length >= size) {
                  yield batch;
                  batch = [];
              }
          }
          if (batch.length) {
              yield batch;
          }
      }

      function intersperse(separator, items) {
          return items.flatMap(item => [separator, item]).slice(1);
      }

      function encodeBits(bits) {
          return Array.from(function*() {
              for (const eightBits of batched(8, bits)) {
                  let byte = 0;
                  for (const [position, bit] of eightBits.entries()) {
                      byte |= bit << position;
                  }
                  if (eightBits.length != 8) {
                      yield String.fromCharCode("f".charCodeAt(0) + eightBits.length);
                  }
                  yield byte.toString(16).padStart(2, "0");
              }
          } ()).join("");
      }

      function* decodeBits(str) {
          let width = 8;
          for (const [matched] of str.matchAll(/[0-9a-f]{2}|[g-m]/g)) {
              switch (matched.length) {
              case 1:
                  width = matched.charCodeAt(0) - "f".charCodeAt(0);
                  break;
              case 2:
                  const byte = parseInt(matched, 16);
                  for (let i = 0; i < width; ++i) {
                      yield (!!(byte & (1 << i)));
                  }
                  width = 8;
                  break;
              }
          }
      }

      const ATTRIBUTES = [
          {
              spellId: 331380,
              name: "Cleanliness Level",
              levels: [
                  {spellId: 327339, name: "Messy", icon: "ability_creature_poison_06"},
                  {spellId: 327340, name: "Clean", icon: "inv_pet_broom"},
              ]
          },
          {
              spellId: 331382,
              name: "Danger Level",
              levels: [
                  {spellId: 327341, name: "Safe", icon: "ability_priest_angelicbulwark"},
                  {spellId: 327342, name: "Dangerous", icon: "achievement_legionpvptier3"},
              ],
          },
          {
              spellId: 331383,
              name: "Decadence Level",
              levels: [
                  {spellId: 327343, name: "Humble", icon: "inv_crate_07"},
                  {spellId: 327344, name: "Decadent", icon: "inv_misc_food_145_cake"},
              ],
          },
          {
              spellId: 331384,
              name: "Excitement Level",
              levels: [
                  {spellId: 327347, name: "Relaxing", icon: "spell_nature_healingtouch"},
                  {spellId: 327346, name: "Exciting", icon: "inv_misc_missilelarge_purple"},
              ],
          },
          {
              spellId: 331385,
              name: "Formality Level",
              levels: [
                  {spellId: 327348, name: "Casual", icon: "inv_shirt_12"},
                  {spellId: 327349, name: "Formal", icon: "inv_shirt_white_01"},
              ],
          },
      ];

      for (const [index, attribute] of ATTRIBUTES.entries()) {
          attribute.index = index;
      }

      const SLOTS = [
          {
              guests: [
                  {name: "Sika", preferences: {0: 1}},
                  {name: "Plague Deviser Marileth", preferences: {0: 0}},
                  {name: "Choofa", preferences: {3: 1}},
                  {name: "Cryptkeeper Kassir", preferences: {4: 1}}
              ],
          },
          {
              guests: [
                  {name: "Kleia and Pelagos", preferences: {2: 0}},
                  {name: "Grandmaster Vole", preferences: {1: 1}},
                  {name: "Droman Aliothe", preferences: {3: 0}},
                  {name: "Stonehead", preferences: {4: 0}}
              ],
          },
          {
              guests: [
                  {name: "Polemarch Adrestes", preferences: {0: 1, 4: 1}},
                  {name: "Alexandros Mograine", preferences: {1: 0, 2: 0}},
                  {name: "Hunt-Captain Korayn", preferences: {1: 1, 4: 0}},
                  {name: "Rendle and Cudgelface", preferences: {0: 0, 3: 0}}
              ],
          },
          {
              guests: [
                  {name: "Mikanikos", preferences: {0: 1, 1: 0, 2: 0}},
                  {name: "Baroness Vashj", preferences: {1: 1, 2: 1, 3: 1}},
                  {name: "Lady Moonberry", preferences: {0: 0, 3: 1, 4: 0}},
                  {name: "The Countess", preferences: {2: 1, 3: 0, 4: 1}}
              ],
          }
      ];

      const GUESTS = [];
      for (const [index, slot] of SLOTS.entries()) {
          slot.index = index;
          slot.number = index + 1;
          for (const [subindex, guest] of slot.guests.entries()) {
              guest.index = GUESTS.length;
              guest.subindex = subindex;
              guest.slot = slot;
              GUESTS.push(guest);
          }
      }

      const BUILDINGS = [
          {
              name: "Entertainment",
              amenities: [
                  {name: "Atoning Rituals", features: {2: 0, 4: 1}},
                  {name: "Glimpse of the Wilds", features: {0: 1, 1: 0}},
                  {name: "Lost Chalice Band", features: {2: 1, 3: 1}}
              ]
          },
          {
              name: "Refreshment",
              amenities: [
                  {name: "Tubbin's Tea Party", features: {3: 0, 4: 1}},
                  {name: "Divine Desserts", features: {0: 0, 2: 1}},
                  {name: "Mushroom Surprise", features: {1: 1, 2: 0}}
              ]
          },
          {
              name: "Decorations",
              amenities: [
                  {name: "Traditional", features: {0: 1, 1: 1}},
                  {name: "Mortal Reminders", features: {3: 0, 4: 0}},
                  {name: "Mystery Mirrors", features: {1: 0, 3: 1}}
              ]
          },
          {
              name: "Security",
              amenities: [
                  {name: "Venthyr Volunteers", features: {1: 1, 3: 1}},
                  {name: "Stoneborn Reserves", features: {1: 0, 2: 1}},
                  {name: "Maldraxxian Army", features: {0: 0, 4: 0}}
              ]
          }
      ];

      const AMENITIES = [];
      for (const [index, building] of BUILDINGS.entries()) {
          building.index = index;
          for (const [subindex, amenity] of building.amenities.entries()) {
              amenity.index = AMENITIES.length;
              amenity.subindex = subindex;
              amenity.building = building;
              AMENITIES.push(amenity);
          }
      }

      function modify(object, ...modifiers) {
          for (const modifier of modifiers) {
              modifier(object);
          }
          return object;
      }

      function makeElement(tagName, attributes, children) {
          const element = document.createElement(tagName)
          for (const [name, value] of Object.entries(attributes)) {
              const match = /^on(.*)$/.exec(name);
              if (match) {
                  element.addEventListener(match[1], value);
              } else {
                  element.setAttribute(name, value);
              }
          }
          for (const child of children) {
              element.append(child);
          }
          return element;
      }

      function identifier(name) {
          return name.toLowerCase().replace(/^[^a-z]|[^0-9a-z]/g, "_");
      }

      function renderIcon(icon) {
          return makeElement("img", {
              "class": "icon",
              "src": `https://wow.zamimg.com/images/wow/icons/tiny/${icon}.gif`,
          }, []);
      }

      function attributeIcon(attribute) {
          const maxLevel = attribute.levels[attribute.levels.length - 1];
          return makeElement("a", {
              "href": `https://wowhead.com/spell=${attribute.spellId}`,
          }, [
              makeElement("img", {
                  "class": "icon",
                  "alt": attribute.name,
                  "src": `https://wow.zamimg.com/images/wow/icons/small/${maxLevel.icon}.jpg`,
              }, []),
          ]);
      }

      function levelIcon(level) {
          return makeElement("a", {
              "href": `https://wowhead.com/spell=${level.spellId}`,
          }, [
              makeElement("img", {
                  "class": "icon",
                  "alt": level.name,
                  "src": `https://wow.zamimg.com/images/wow/icons/small/${level.icon}.jpg`,
              }, []),
          ]);
      }

      function renderLevel(level) {
          return makeElement("span", {"class": `level level-${level.name}`}, [
              renderIcon(level.icon),
              " ",
              level.name,
          ]);
      }

      function onchange() {
          setHashFromState();
          updateAll();
      }

      function checkAll(checkbox, container) {
          for (const cb of document.querySelectorAll(`#${container} td > input[type=checkbox]`)) {
              cb.checked = checkbox.checked;
          }
          setHashFromState();
          updateAll();
      }

      function updateCheckAll(checkbox, container) {
          let checked = null;
          for (const cb of document.querySelectorAll(`#${container} td > input[type=checkbox]`)) {
              if (checked == null) {
                  checked = cb.checked;
              } else if (checked != cb.checked) {
                  checkbox.checked = true;
                  checkbox.indeterminate = true;
                  return;
              }
          }
          checkbox.checked = checked;
          checkbox.indeterminate = false;
      }

      function replaceClass(className, regexp, newClass) {
          const classes = className.split(/ +/).filter(c => !regexp.test(c));
          classes.push(newClass);
          return classes.join(" ");
      }

      function interpolate(a, b, t) {
          return a + (b - a) * t;
      }
      
      function updateAll() {
          updateCheckAll(document.getElementById("guests-all"), "guests");
          updateCheckAll(document.getElementById("amenities-all"), "amenities");
          const slotWeights = SLOTS.map(() => 0);
          for (const guest of GUESTS) {
              if (guest.checkbox.checked) {
                  ++slotWeights[guest.slot.index];
              }
          }
          const preferences = ATTRIBUTES.map(() => 0);
          for (const guest of GUESTS) {
              if (guest.checkbox.checked) {
                  const guestPreferences = Object.entries(guest.preferences);
                  for (const [attribute, level] of guestPreferences) {
                      const sign = (2 * level - 1);
                      preferences[attribute] += sign
                          / slotWeights[guest.slot.index]
                          / guestPreferences.length;
                  }
              }
          }
          const buildingWeights = BUILDINGS.map(() => 0);
          for (const amenity of AMENITIES) {
              if (amenity.checkbox.checked) {
                  ++buildingWeights[amenity.building.index];
              }
          }
          const features = ATTRIBUTES.map(() => 0);
          for (const amenity of AMENITIES) {
              if (amenity.checkbox.checked) {
                  const amenityFeatures = Object.entries(amenity.features);
                  for (const [attribute, level] of amenityFeatures) {
                      const sign = (2 * level - 1);
                      features[attribute] += sign
                          / buildingWeights[amenity.building.index]
                          / (1 + (Math.sign(sign) != Math.sign(preferences[attribute])));
                  }
              }
          }
          for (const [attribute, preference] of preferences.entries()) {
              for (const td of document.querySelectorAll(`#guests td.attribute-${attribute}`)) {
                  const lightness = interpolate(
                      0.05,
                      0.8,
                      Math.pow(Math.abs(preference) / 1.84, 0.5));
                  const color = `hsl(60deg 40% ${lightness * 100}%)`;
                  console.log("PREFERENCE", ATTRIBUTES[attribute].name, preference, color);
                  td.className = replaceClass(td.className, /^atmosphere-/, 
                                              preference > 0 ? "atmosphere-high" :
                                              preference < 0 ? "atmosphere-low" :
                                              "atmosphere-mid");
//                  td.style.backgroundColor = color;
              }
          }
          for (const [attribute, feature] of features.entries()) {
              for (const td of document.querySelectorAll(`#amenities td.attribute-${attribute}`)) {
                  const lightness = interpolate(
                      0.05,
                      0.8,
                      Math.pow(Math.abs(feature) / 3, 0.5));
                  const color = `hsl(60deg 40% ${lightness * 100}%)`;
                  console.log("FEATURE", ATTRIBUTES[attribute].name, feature, color);
                  td.className = replaceClass(td.className, /^atmosphere-/, 
                                              feature > 0 ? "atmosphere-high" :
                                              feature < 0 ? "atmosphere-low" :
                                              "atmosphere-mid");
              }
          }
      }

      document.getElementById("guests").append(
          makeElement("tr", {}, [
              ...[
                  makeElement("th", {}, []),
                  makeElement("th", {}, [
                      makeElement("input", {
                          "id": "guests-all",
                          "type": "checkbox",
                          "checked": "",
                          "onchange": e => checkAll(e.target, "guests"),
                      }, []),
                  ]),
                  makeElement("th", {}, [
                      makeElement("label", {"for": "guests-all"}, ["Guest"]),
                  ]),
              ],
              ...ATTRIBUTES.map(attribute =>
                  makeElement("th", {}, [attributeIcon(attribute)])
              ),
          ]),
          ...GUESTS.map(guest => {
              const checkbox = makeElement("input", {
                  "id": `guest-${guest.index}`,
                  "type": "checkbox",
                  "checked": "",
                  "onchange": onchange,
              }, []);
              guest.checkbox = checkbox;
              return makeElement("tr", {}, [
                  ...(guest.subindex == 0 ? [
                      makeElement("th", {"rowspan": guest.slot.guests.length}, [
                          `Guest ${guest.slot.number}`,
                      ]),
                  ] : []),
                  ...[
                      makeElement("td", {"class": "selectable"}, [checkbox]),
                      makeElement("td", {"class": "selectable"}, [
                          makeElement("label", {"for": checkbox.id}, [guest.name]),
                      ]),
                  ],
                  ...ATTRIBUTES.map(attribute => {
                      const levelIndex = guest.preferences[attribute.index];
                      return makeElement(
                          "td",
                          {"class": `selectable attribute-${attribute.index} level-${levelIndex ? "high" : "low"}`},
                          levelIndex != undefined ? [levelIcon(attribute.levels[levelIndex])] : [],
                      )
                  }),
              ]);
          }),
      );

      document.getElementById("amenities").append(
          makeElement("tr", {}, [
              ...[
                  makeElement("th", {}, []),
                  makeElement("th", {}, [
                      modify(
                          makeElement("input", {
                              "id": "amenities-all",
                              "type": "checkbox",
                              "checked": true,
                              "onchange": e => checkAll(e.target, "amenities"),
                          }, []),
                      ),
                  ]),
                  makeElement("th", {}, [
                      makeElement("label", {"for": "amenities-all"}, ["Amenity"]),
                  ]),
              ],
              ...ATTRIBUTES.map(attribute =>
                  makeElement("th", {}, [attributeIcon(attribute)])
              ),
          ]),
          ...AMENITIES.map(amenity => {
              const checkbox = makeElement("input", {
                  "id": `amenity-${amenity.index}`,
                  "type": "checkbox",
                  "checked": true,
                  "onchange": onchange,
              }, []);
              amenity.checkbox = checkbox;
              return makeElement("tr", {}, [
                  ...(amenity.subindex == 0 ? [
                      makeElement("th", {"rowspan": amenity.building.amenities.length}, [
                          amenity.building.name,
                      ]),
                  ] : []),
                  ...[
                      makeElement("td", {"class": "selectable"}, [checkbox]),
                      makeElement("td", {"class": "selectable"}, [
                          makeElement("label", {"for": checkbox.id}, [amenity.name]),
                      ]),
                  ],
                  ...ATTRIBUTES.map(attribute => {
                      const levelIndex = amenity.features[attribute.index];
                      return makeElement(
                          "td",
                          {"class": `selectable attribute-${attribute.index} level-${levelIndex ? "high" : "low"}`},
                          levelIndex != undefined ? [levelIcon(attribute.levels[levelIndex])] : [],
                      )
                  }),
              ]);
          }),
      );

      const CHECKBOXES = [
          ...GUESTS.map(guest => guest.checkbox),
          ...AMENITIES.map(amenity => amenity.checkbox),
      ];

      function getState() {
          return encodeBits(function*() {
              for (const checkbox of CHECKBOXES) {
                  yield +checkbox.checked;
              }
          }());
      }

      function setState(state) {
          const bits = decodeBits(state);
          for (const checkbox of CHECKBOXES) {
              const bit = bits.next().value;
              checkbox.checked = bit == undefined ? true : bit;
          }
      }

      function setHashFromState() {
          history.pushState(null, "", "#" + getState());
      }

      function setStateFromHash() {
          setState(location.hash.replace(/^#/, ""));
      }

      window.addEventListener("popstate", event => {
          console.log("popstate!");
          setStateFromHash();
      });
      setStateFromHash();
      setHashFromState();
      updateAll();
    </script>
    <script>const whTooltips = {};</script>
    <script src="https://wow.zamimg.com/js/tooltips.js"></script>
  </body>
</html>
