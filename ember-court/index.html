<!doctype html>
<html>
  <head>
    <title>Ember Court Planner</title>
    <style>
      html {
          font-family: sans-serif;
          background: #111;
          color: #ddd;
      }
      .matrix {
          vertical-align: middle;
          border-collapse: collapse;
          display: inline-block;
          margin: 5px;
      }
      .matrix td, .matrix th {
          border: solid 1px #777;
          padding: 4px;
          text-align: left;
      }
      .matrix th {
          background: #000;
      }
      .matrix td > label {
          display: block;
      }
      .matrix tr:has(> td > input[type="checkbox"]:checked) td.selectable {
          background: #292929;
      }
      img.icon {
          border: 1px solid #000;
          border-radius: 2px;
          box-shadow: 0 0 3px 2px #000;
          vertical-align: middle;
      }
      tr:has(> td > input[type="checkbox"]:checked) .level-low.atmosphere-low img,
      tr:has(> td > input[type="checkbox"]:checked) .level-high.atmosphere-high img {
          box-shadow: 0 0 3px 2px #ddd;
//          border-color: #ddd;
      }
      .level-low.atmosphere-high,
      .level-high.atmosphere-low {
       //   background-color: #d5151540;
      }
      .level-low.atmosphere-high img,
      .level-high.atmosphere-low img {
          opacity: 20%;
      }
      tr:has(> td > input[type="checkbox"]:checked) .level-low.atmosphere-high img,
      tr:has(> td > input[type="checkbox"]:checked) .level-high.atmosphere-low img {
          box-shadow: 0 0 3px 2px #f00;
          opacity: 70%;
      }
      tr:has(> td > input[type="checkbox"]:checked) .level-low.atmosphere-mid img,
      tr:has(> td > input[type="checkbox"]:checked) .level-high.atmosphere-mid img {
          box-shadow: 0 0 3px 2px #ff0;
          opacity: 70%;
      }
      .atmosphere-mid img {
          opacity: 80%;
      }
    </style>
  </head>
  <body>
    <table id="guests" class="matrix"></table>
    <table id="amenities" class="matrix"></table>
    <script>
      function* chain(...iters) {
          for (const items of iters) {
              for (const item of items) {
                  yield item;
              }
          }
      }

      function* batched(size, items) {
          let batch = [];
          for (const item of items) {
              batch.push(item);
              if (batch.length >= size) {
                  yield batch;
                  batch = [];
              }
          }
          if (batch.length) {
              yield batch;
          }
      }

      function intersperse(separator, items) {
          return items.flatMap(item => [separator, item]).slice(1);
      }

      // 'type' can be either Number or BigInt.
      function packBits(type, bits) {
          let integer = type(0);
          let position = type(0);
          for (const bit of bits) {
              integer |= bit << position;
              ++position;
          }
          return integer;
      }

      const ATTRIBUTES = [
          {
              spellId: 331380,
              name: "Cleanliness Level",
              levels: [
                  {spellId: 327339, name: "Messy", icon: "ability_creature_poison_06"},
                  {spellId: 327340, name: "Clean", icon: "inv_pet_broom"},
              ]
          },
          {
              spellId: 331382,
              name: "Danger Level",
              levels: [
                  {spellId: 327341, name: "Safe", icon: "ability_priest_angelicbulwark"},
                  {spellId: 327342, name: "Dangerous", icon: "achievement_legionpvptier3"},
              ],
          },
          {
              spellId: 331383,
              name: "Decadence Level",
              levels: [
                  {spellId: 327343, name: "Humble", icon: "inv_crate_07"},
                  {spellId: 327344, name: "Decadent", icon: "inv_misc_food_145_cake"},
              ],
          },
          {
              spellId: 331384,
              name: "Excitement Level",
              levels: [
                  {spellId: 327347, name: "Relaxing", icon: "spell_nature_healingtouch"},
                  {spellId: 327346, name: "Exciting", icon: "inv_misc_missilelarge_purple"},
              ],
          },
          {
              spellId: 331385,
              name: "Formality Level",
              levels: [
                  {spellId: 327348, name: "Casual", icon: "inv_shirt_12"},
                  {spellId: 327349, name: "Formal", icon: "inv_shirt_white_01"},
              ],
          },
      ];

      for (const [index, attribute] of ATTRIBUTES.entries()) {
          attribute.index = index;
      }

      const SLOTS = [
          {
              options: [
                  {name: "Sika", attributes: {0: 1}},
                  {name: "Plague Deviser Marileth", attributes: {0: 0}},
                  {name: "Choofa", attributes: {3: 1}},
                  {name: "Cryptkeeper Kassir", attributes: {4: 1}}
              ],
          },
          {
              options: [
                  {name: "Kleia and Pelagos", attributes: {2: 0}},
                  {name: "Grandmaster Vole", attributes: {1: 1}},
                  {name: "Droman Aliothe", attributes: {3: 0}},
                  {name: "Stonehead", attributes: {4: 0}}
              ],
          },
          {
              options: [
                  {name: "Polemarch Adrestes", attributes: {0: 1, 4: 1}},
                  {name: "Alexandros Mograine", attributes: {1: 0, 2: 0}},
                  {name: "Hunt-Captain Korayn", attributes: {1: 1, 4: 0}},
                  {name: "Rendle and Cudgelface", attributes: {0: 0, 3: 0}}
              ],
          },
          {
              options: [
                  {name: "Mikanikos", attributes: {0: 1, 1: 0, 2: 0}},
                  {name: "Baroness Vashj", attributes: {1: 1, 2: 1, 3: 1}},
                  {name: "Lady Moonberry", attributes: {0: 0, 3: 1, 4: 0}},
                  {name: "The Countess", attributes: {2: 1, 3: 0, 4: 1}}
              ],
          }
      ];

      const MAX_PREFERENCE = 6;
      const GUESTS = Array.from(function*() {
          let i = 0;
          for (const [index, slot] of SLOTS.entries()) {
              slot.index = index;
              slot.name = `Guest ${index + 1}`;
              for (const [subindex, guest] of slot.options.entries()) {
                  const attributes = Object.entries(guest.attributes);
                  guest.index = i++;
                  guest.subindex = subindex;
                  guest.group = slot;
                  guest.preferences = new Int8Array(ATTRIBUTES.length);
                  for (const [attribute, level] of attributes) {
                      const numerator = (2 * level - 1) * MAX_PREFERENCE;
                      console.assert(numerator % attributes.length == 0);
                      guest.preferences[attribute] = numerator / attributes.length;
                  }
                  yield guest;
              }
          }
      } ());

      const BUILDINGS = [
          {
              name: "Entertainment",
              options: [
                  {name: "Atoning Rituals", attributes: {2: 0, 4: 1}},
                  {name: "Glimpse of the Wilds", attributes: {0: 1, 1: 0}},
                  {name: "Lost Chalice Band", attributes: {2: 1, 3: 1}}
              ]
          },
          {
              name: "Refreshment",
              options: [
                  {name: "Tubbin's Tea Party", attributes: {3: 0, 4: 1}},
                  {name: "Divine Desserts", attributes: {0: 0, 2: 1}},
                  {name: "Mushroom Surprise", attributes: {1: 1, 2: 0}}
              ]
          },
          {
              name: "Decorations",
              options: [
                  {name: "Traditional", attributes: {0: 1, 1: 1}},
                  {name: "Mortal Reminders", attributes: {3: 0, 4: 0}},
                  {name: "Mystery Mirrors", attributes: {1: 0, 3: 1}}
              ]
          },
          {
              name: "Security",
              options: [
                  {name: "Venthyr Volunteers", attributes: {1: 1, 3: 1}},
                  {name: "Stoneborn Reserves", attributes: {1: 0, 2: 1}},
                  {name: "Maldraxxian Army", attributes: {0: 0, 4: 0}}
              ]
          }
      ];

      const AMENITIES = Array.from(function*() {
          let i = 0;
          for (const [index, building] of BUILDINGS.entries()) {
              building.index = index;
              for (const [subindex, amenity] of building.options.entries()) {
                  amenity.index = i++;
                  amenity.subindex = subindex;
                  amenity.group = building;
                  yield amenity;
              }
          }
      } ());

      function makeElement(tagName, attributes, children) {
          const element = document.createElement(tagName)
          for (const [name, value] of Object.entries(attributes)) {
              const match = /^on(.*)$/.exec(name);
              if (match) {
                  element.addEventListener(match[1], value);
              } else {
                  element.setAttribute(name, value);
              }
          }
          for (const child of children) {
              element.append(child);
          }
          return element;
      }

      function attributeIcon(attribute) {
          const maxLevel = attribute.levels[attribute.levels.length - 1];
          return makeElement("a", {
              "href": `https://wowhead.com/spell=${attribute.spellId}`,
          }, [
              makeElement("img", {
                  "class": "icon",
                  "alt": attribute.name,
                  "src": `https://wow.zamimg.com/images/wow/icons/small/${maxLevel.icon}.jpg`,
              }, []),
          ]);
      }

      function levelIcon(level) {
          return makeElement("a", {
              "href": `https://wowhead.com/spell=${level.spellId}`,
          }, [
              makeElement("img", {
                  "class": "icon",
                  "alt": level.name,
                  "src": `https://wow.zamimg.com/images/wow/icons/small/${level.icon}.jpg`,
              }, []),
          ]);
      }

      function onchange() {
          setHashFromState();
          updateAll();
      }

      function checkAll(checkbox, container) {
          for (const cb of document.querySelectorAll(`#${container} td > input[type=checkbox]`)) {
              cb.checked = checkbox.checked;
          }
          setHashFromState();
          updateAll();
      }

      function updateCheckAll(checkbox, container) {
          let checked = null;
          for (const cb of document.querySelectorAll(`#${container} td > input[type=checkbox]`)) {
              if (checked == null) {
                  checked = cb.checked;
              } else if (checked != cb.checked) {
                  checkbox.checked = true;
                  checkbox.indeterminate = true;
                  return;
              }
          }
          checkbox.checked = checked;
          checkbox.indeterminate = false;
      }

      function replaceClass(className, regexp, newClass) {
          const classes = className.split(/ +/).filter(c => !regexp.test(c));
          classes.push(newClass);
          return classes.join(" ");
      }

      function interpolate(a, b, t) {
          return a + (b - a) * Math.max(0, Math.min(1, t));
      }

      function updateAll() {
          execute();
          updateCheckAll(document.getElementById("guests-all"), "guests");
          updateCheckAll(document.getElementById("amenities-all"), "amenities");
          const slotWeights = SLOTS.map(() => 0);
          for (const guest of GUESTS) {
              if (guest.checkbox.checked) {
                  ++slotWeights[guest.group.index];
              }
          }
          const preferences = ATTRIBUTES.map(() => 0);
          for (const guest of GUESTS) {
              if (guest.checkbox.checked) {
                  const guestAttributes = Object.entries(guest.attributes);
                  for (const [attribute, level] of guestAttributes) {
                      const sign = (2 * level - 1);
                      preferences[attribute] += sign
                          / slotWeights[guest.group.index]
                          / guestAttributes.length;
                  }
              }
          }
          const buildingWeights = BUILDINGS.map(() => 0);
          for (const amenity of AMENITIES) {
              if (amenity.checkbox.checked) {
                  ++buildingWeights[amenity.group.index];
              }
          }
          const features = ATTRIBUTES.map(() => 0);
          for (const amenity of AMENITIES) {
              if (amenity.checkbox.checked) {
                  const amenityAttributes = Object.entries(amenity.attributes);
                  for (const [attribute, level] of amenityAttributes) {
                      const sign = (2 * level - 1);
                      features[attribute] += sign
                          / buildingWeights[amenity.group.index]
                          / (1 + (Math.sign(sign) != Math.sign(preferences[attribute])));
                  }
              }
          }
          for (const [attribute, preference] of preferences.entries()) {
              for (const td of document.querySelectorAll(`#guests td.attribute-${attribute}`)) {
                  const lightness = interpolate(
                      0.05,
                      0.8,
                      Math.pow(Math.abs(preference) / 1.84, 0.5));
                  const color = `hsl(60deg 40% ${lightness * 100}%)`;
//                  console.log("PREFERENCE", ATTRIBUTES[attribute].name, preference, color);
                  td.className = replaceClass(td.className, /^atmosphere-/,
                                              preference > 0 ? "atmosphere-high" :
                                              preference < 0 ? "atmosphere-low" :
                                              "atmosphere-mid");
//                  td.style.backgroundColor = color;
              }
          }
          for (const [attribute, feature] of features.entries()) {
              for (const td of document.querySelectorAll(`#amenities td.attribute-${attribute}`)) {
                  const lightness = interpolate(
                      0.05,
                      0.8,
                      Math.pow(Math.abs(feature) / 3, 0.5));
                  const color = `hsl(60deg 40% ${lightness * 100}%)`;
//                  console.log("FEATURE", ATTRIBUTES[attribute].name, feature, color);
                  td.className = replaceClass(td.className, /^atmosphere-/,
                                              feature > 0 ? "atmosphere-high" :
                                              feature < 0 ? "atmosphere-low" :
                                              "atmosphere-mid");
              }
          }
      }

      function makeTableRows(parentName, title, entities) {
          return [
              makeElement("tr", {}, [
                  ...[
                      makeElement("th", {}, [
                          makeElement("input", {
                              "id": `${parentName}-all`,
                              "type": "checkbox",
                              "checked": "",
                              "onchange": e => checkAll(e.target, parentName),
                          }, []),
                      ]),
                      makeElement("th", {}, [title]),
                  ],
                  ...ATTRIBUTES.map(attribute =>
                      makeElement("th", {}, [attributeIcon(attribute)])
                  ),
                  makeElement("th", {}, []),
              ]),
              ...entities.flatMap(entity => {
                  const checkbox = makeElement("input", {
                      "id": `${parentName}-entity-${entity.index}`,
                      "type": "checkbox",
                      "checked": "",
                      "onchange": onchange,
                  }, []);
                  entity.checkbox = checkbox;
                  const prefix =
                        entity.subindex == 0 ?
                        [makeElement("tr", {}, [
                            makeElement("th", {}, []),
                            makeElement("th", {}, [entity.group.name]),
                            makeElement("th", {"colspan": ATTRIBUTES.length + 1}, []),
                        ])] : [];
                  return [...prefix, makeElement("tr", {}, [
                      ...[
                          makeElement("td", {"class": "selectable"}, [checkbox]),
                          makeElement("td", {"class": "selectable"}, [
                              makeElement("label", {"for": checkbox.id}, [entity.name]),
                          ]),
                      ],
                      ...ATTRIBUTES.map(attribute => {
                          const levelIndex = entity.attributes[attribute.index];
                          const levelClass =
                                levelIndex == 0 ? "level-low" :
                                levelIndex == 1 ? "level-high" :
                                "level-mid";
                          return makeElement(
                              "td",
                              {"class": `selectable attribute-${attribute.index} ${levelClass}`},
                              levelIndex != undefined ? [levelIcon(attribute.levels[levelIndex])] : [],
                          )
                      }),
                      makeElement("td", {
                          "id": `${parentName}-score-${entity.index}`,
                          "style": "font-family: monospace; font-size: small; text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;",
                      }, ["000"]),
                  ])];
              }),
          ];
      }

      document.getElementById("guests").append(
          ...makeTableRows("guests", "Guests", GUESTS),
      );
      document.getElementById("amenities").append(
          ...makeTableRows("amenities", "Amenities", AMENITIES),
      );

      const CHECKBOXES = [
          ...GUESTS.map(guest => guest.checkbox),
          ...AMENITIES.map(amenity => amenity.checkbox),
      ];

      function getState() {
          return packBits(Number, CHECKBOXES.map(checkbox => checkbox.checked))
              .toString(16).padStart(Math.ceil(CHECKBOXES.length / 4), "0");
      }

      function setState(state) {
          const bits = parseInt(state, 16);
          for (const [i, checkbox] of CHECKBOXES.entries()) {
              checkbox.checked = Number.isNaN(bits) ? true : bits & (1 << i);
          }
      }

      function setHashFromState() {
          history.pushState(null, "", "#" + getState());
      }

      function setStateFromHash() {
          setState(location.hash.replace(/^#/, ""));
      }

      window.addEventListener("popstate", setStateFromHash);
      setStateFromHash();
      setHashFromState();
      updateAll();

      function* productInner(prefix, iters) {
          if (prefix.length >= iters.length) {
              yield prefix;
              return;
          }
          for (const item of iters[prefix.length]) {
              prefix.push(item);
              yield* productInner(prefix, iters);
              prefix.pop();
          }
      }

      function* product(...iters) {
          yield* productInner([], iters);
      }

      function checkedOptions(entity) {
          const filtered = entity.options.filter(o => o.checkbox.checked);
          if (filtered.length == 0) {
              return [];
          }
          return [filtered];
      }

      function execute() {
          const startTime = performance.now()

          const amenityCombos = Array.from(function*() {
              for (const amenities of product(...BUILDINGS.flatMap(checkedOptions))) {
                  const negFeatures = new Int8Array(ATTRIBUTES.length);
                  const posFeatures = new Int8Array(ATTRIBUTES.length);
                  for (const amenity of amenities) {
                      for (const [attribute, level] of Object.entries(amenity.attributes)) {
                          if (level) {
                              ++posFeatures[attribute];
                          } else {
                              ++negFeatures[attribute];
                          }
                      }
                  }
                  const amenityIndices = amenities.map(a => a.index);
                  yield {amenityIndices, negFeatures, posFeatures}
              }
          } ());
          const guestCombos = Array.from(function*() {
              for (const guests of product(...SLOTS.flatMap(checkedOptions))) {
                  const preferences = new Int8Array(ATTRIBUTES.length);
                  for (const guest of guests) {
                      for (const [attribute, preference] of guest.preferences.entries()) {
                          preferences[attribute] += preference;
                      }
                  }
                  const guestIndices = guests.map(a => a.index);
                  yield {guestIndices, preferences};
              }
          } ());

          let minScore = Infinity;
          let maxScore = -Infinity;
          const guestScores = GUESTS.map(() => ({totalScore: 0, count: 0, maxScore: -Infinity}));
          const amenityScores = AMENITIES.map(() => ({totalScore: 0, count: 0, maxScore: -Infinity}));
          // TODO: Add -1? penalty per amenity feature used
          // TODO: Add 8+1n bonus per amenity feature surplus
          for (const {guestIndices, preferences} of guestCombos) {
              for (const {amenityIndices, negFeatures, posFeatures} of amenityCombos) {
                  const score = ATTRIBUTES
                        .map(attribute => {
                            const PASSIVE = 1;
                            const ACTIVE = 10;
                            const i = attribute.index;
                            const p = preferences[i];
                            const f = p > 0
                                  ? ACTIVE * posFeatures[i] - PASSIVE * negFeatures[i]
                                  : PASSIVE * posFeatures[i] - ACTIVE * negFeatures[i];
                            console.log(p, f, posFeatures, negFeatures);
                            return p * f + p * 10;
                        })
                        .reduce((x, y) => x + y, 0);
                  for (const index of guestIndices) {
                      const marginScore = guestScores[index];
                      marginScore.totalScore += score;
                      marginScore.maxScore = Math.max(marginScore.maxScore, score);
                      marginScore.count += 1;
                  }
                  for (const index of amenityIndices) {
                      const marginScore = amenityScores[index];
                      marginScore.totalScore += score;
                      marginScore.maxScore = Math.max(marginScore.maxScore, score);
                      marginScore.count += 1;
                  }
                  minScore = Math.min(minScore, score);
                  maxScore = Math.max(maxScore, score);
              }
          }
          for (const [parentName, marginScores] of [["guests", guestScores], ["amenities", amenityScores]]) {
              for (const [index, score] of marginScores.entries()) {
                  const permille = Math.max(0, Math.round(score.maxScore));
                  const td = document.getElementById(`${parentName}-score-${index}`);
                  td.innerText = permille.toString().padStart(3, "0");
                  td.style.backgroundColor = `hsl(60deg 50% ${interpolate(0, 100, permille / 1000)}%)`;
              }
          }
          console.log(performance.now() - startTime, "ms", minScore, "~", maxScore);
      }
    </script>
    <script>const whTooltips = {};</script>
    <script src="https://wow.zamimg.com/js/tooltips.js"></script>
  </body>
</html>
